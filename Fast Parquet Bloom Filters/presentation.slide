# Fast Parquet Bloom Filters
11 March 2025
Tags: parquet-go, parquet, bloom, filters
Summary: This presentation showcases the optimizations that were made to the bloom filter implementation in parquet-go

Achille Roussel
CTO, Firetiger
achille@firetiger.com
https://firetiger.com
achille-roussel (Github)

## Speaker

.link https://github.com/achille-roussel

- Moved to **San Francisco** in 2011
- Go developer & contributor
- OSS projects: **ksuid, kafka-go, parquet-go, ...**
- Career at **Twitch, Facebook, Segment, Twilio**
- Co-Founded [**Firetiger**](https://firetiger.com) in 2024

: I'm originally from France, and move to SF in 2011.
: I've been using Go for over 10 years.
: I contributed to the 
: I authored and maintain a couple of open source Go packages, some of the popular ones you may know about like ksuid, kafka-go, or parquet-go.
: I've done my career in the Bay Area, oscilliating between startups and larger companies.
: Last year I co-founded a company.
: And bBefore we jump into today's topic, let me tell you a bit about what we do.

## Firetiger

.link https://firetiger.com

- Datalake for telemetry
- Streaming OpenTelemetry to Apache Iceberg
- Per-customer monitoring

## Apache Iceberg

.link https://iceberg.apache.org

- Open-Table specification
- Columnar file layout (Parquet)
- Java ecosystem → Go?

.link https://github.com/firetiger-oss/iceberg
.link https://github.com/parquet-go/parquet-go

## Challenges

- High write throughput (1M+ row/s)
- Most of the data is never read
- Querying over large datasets (PB)

## What are Bloom Filters?

> *A Bloom filter is a space-efficient probabilistic data structure designed to test whether an element is a member of a set.*

Lossy compression mechanism (reduce value to a fixed set of bits).

Useful for point lookups:
```

SELECT * FROM records WHERE id = '070A8618-2199-4E24-9B29-01826EC533C9'

```

## Why are Bloom Filters useful?

- Accelerate queries
- Memory efficent
- More bits = Fewer false positives

```
| Bits of space per insert | False positive probability |
| ------------------------ | -------------------------- |
|                      6.0 |                     10.0 % |
|                     10.5 |                      1.0 % |
|                     16.9 |                      0.1 % |
|                     26.4 |                     0.01 % |
|                     41.0 |                    0.001 % |
```

: Bloom Filters are useful to accelerate queries by reducing the amount of data that needs to be touched to find matching records.
: They are memory efficient because they only store a fixed number of bits regardless of the size of the original value that was inserted in the filter.

## How are Bloom Filters implemented?

	var filter []byte

Insert
```

	h := hash(value) % 8*len(filter)
	i := h / 8
	j := h % 8
	
	filter[i] |= 1 << j

```

Check
```

	h := hash(value) % 8*len(filter)
	i := h / 8
	j := h % 8
	
	(filter[i] & (1 << j)) != 0

```

## How are Bloom Filters used?

First test if the value probably exist in the file (~% chance of being wrong)

Filter out all files that do no contain the value

## Bloom Filters Performance Analysis

Bottlenecks in simple bloom filter implementations:
- Modulo
- Hashing
- CPU cache misses

## Bloom Filters Performance Analysis: Modulo

Expensive when performed on hot code paths

## Bloom Filters Performance Analysis: Hashing

Hashing the value multiple times increases the baseline cost

## Bloom Filters Performance Analysis: CPU cache misses

Setting bits at random locations in memory causes large number of CPU cache misses

: To understand why this is bad, consider that when a CPU writes to memory, it first reads a 64 bytes cache line, mutates it, and write it back.
: This can be pipelines when memory writes touch the same cache line.
: Batching is the only optimization.

## Bloom Filters in Parquet

Split-Block Filters:
- Split filter in 32 bytes chunks
- Two-step hashing with xxhash and fast hash
- Set 8 bits in a 256 bit block

```

func fasthash1x64(value uint64, scale int32) uint64 {
	return ((value >> 32) * uint64(scale)) >> 32
}

```

```
goos: linux
goarch: amd64
cpu: AMD EPYC 9B14
```

: We can see that split-block filters is parquet have an optimial design:
: - They use bitshift instead of modulo operations
: - xxhash is a fast hashing algorithm
: - spliting the filter into block ensures at most one cache miss when reading or writing a value
: - 8 bits give close to 1% error rate, good balance of write throughput vs query latency
: We get a lot out of the box just from the design, but there's more we can do!

## Optimzing Parquet Bloom Filters: Bulk Operations

.link https://www.youtube.com/watch?v=rX0ItVEVjHc CppCon 2014: Mike Acton "Data-Oriented Design and C++"
---

## Optimizing Parquet Bloom Filters: SIMD Insert / Check

```
pkg: github.com/parquet-go/parquet-go/bloom

                 │ /tmp/bench.purego │          /tmp/bench.amd64           │
                 │      sec/op       │   sec/op     vs base                │
BlockInsert              4.644n ± 2%   3.232n ± 1%  -30.40% (p=0.000 n=10)
BlockCheck               4.555n ± 5%   2.062n ± 0%  -54.72% (p=0.000 n=10)
FilterInsertBulk         93.07n ± 4%   14.88n ± 2%  -84.02% (p=0.000 n=10)
FilterInsert             5.645n ± 6%   3.252n ± 4%  -42.39% (p=0.000 n=10)
FilterCheck              5.910n ± 7%   2.361n ± 0%  -60.06% (p=0.000 n=10)
geomean                  6.417n        3.056n       -52.38%

                 │ /tmp/bench.purego │            /tmp/bench.amd64            │
                 │        B/s        │      B/s       vs base                 │
BlockInsert             6.417Gi ± 2%    9.220Gi ± 1%   +43.68% (p=0.000 n=10)
BlockCheck              6.543Gi ± 5%   14.450Gi ± 0%  +120.86% (p=0.000 n=10)
FilterInsertBulk        5.124Gi ± 4%   32.050Gi ± 2%  +525.53% (p=0.000 n=10)
FilterInsert            5.279Gi ± 6%    9.165Gi ± 4%   +73.59% (p=0.000 n=10)
FilterCheck             5.043Gi ± 6%   12.625Gi ± 0%  +150.33% (p=0.000 n=10)
geomean                 7.372Gi         15.48Gi       +110.00%
```

.link https://github.com/parquet-go/parquet-go/blob/main/bloom/block_amd64.s
.link https://github.com/parquet-go/parquet-go/blob/main/bloom/filter_amd64.s

## Optimizing Parquet Bloom Filters: SIMD XXHash

Bulk xxhash implementations to compute multiple hash values in parallel

```

func MultiSum64Uint8(h []uint64, v []uint8) int

func MultiSum64Uint16(h []uint64, v []uint16) int

func MultiSum64Uint32(h []uint64, v []uint32) int

func MultiSum64Uint64(h []uint64, v []uint64) int

func MultiSum64Uint128(h []uint64, v [][16]byte) int

```

.link https://github.com/parquet-go/parquet-go/blob/main/bloom/xxhash/sum64uint_amd64.s

## Optimizing Parquet Bloom Filters: SIMD XXHash

```
pkg: github.com/parquet-go/parquet-go/bloom/xxhash

                      │ /tmp/xxhash.purego │           /tmp/xxhash.amd64            │
                      │        B/s         │      B/s       vs base                 │
MultiSum64Uint8/4KB           3.823Gi ± 3%   26.077Gi ± 1%  +582.11% (p=0.000 n=10)
MultiSum64Uint16/4KB          2.805Gi ± 3%   17.466Gi ± 1%  +522.77% (p=0.000 n=10)
MultiSum64Uint32/4KB          3.813Gi ± 3%   23.796Gi ± 1%  +523.99% (p=0.000 n=10)
MultiSum64Uint64/4KB          3.517Gi ± 5%   19.870Gi ± 0%  +465.01% (p=0.000 n=10)
MultiSum64Uint128/4KB         1.388Gi ± 4%   11.721Gi ± 1%  +744.58% (p=0.000 n=10)
geomean                       2.884Gi         19.07Gi       +561.32%

                      │ /tmp/xxhash.purego │           /tmp/xxhash.amd64           │
                      │       hash/s       │    hash/s     vs base                 │
MultiSum64Uint8/4KB            513.1M ± 3%   3500.1M ± 1%  +582.11% (p=0.000 n=10)
MultiSum64Uint16/4KB           376.4M ± 3%   2344.2M ± 1%  +522.77% (p=0.000 n=10)
MultiSum64Uint32/4KB           511.8M ± 3%   3193.8M ± 1%  +523.98% (p=0.000 n=10)
MultiSum64Uint64/4KB           472.0M ± 5%   2666.9M ± 0%  +465.01% (p=0.000 n=10)
MultiSum64Uint128/4KB          186.3M ± 4%   1573.2M ± 1%  +744.58% (p=0.000 n=10)
geomean                        387.1M         2.560G       +561.32%
```

## Recap

To create high performance Bloom Filters:
- Undersand hardware
- Data-oriented deisng
- Leverage SIMD instructions

```

goarch: amd64
pkg: github.com/parquet-go/parquet-go
cpu: AMD EPYC 9B14

                 │ /tmp/filter.purego │          /tmp/filter.amd64          │
                 │       sec/op       │   sec/op     vs base                │
SplitBlockFilter          8.497µ ± 6%   1.271µ ± 2%  -85.04% (p=0.000 n=10)

                 │ /tmp/filter.purego │           /tmp/filter.amd64            │
                 │        B/s         │      B/s       vs base                 │
SplitBlockFilter         897.9Mi ± 5%   6000.8Mi ± 2%  +568.28% (p=0.000 n=10)

```
